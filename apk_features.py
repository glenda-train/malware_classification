# ----------------------------------------------------------------------------------------------------------------------
import os
import random
import numpy as np
import pandas as pd

# Global lib to read XML files
import xml.etree.ElementTree as ET
# ----------------------------------------------------------------------------------------------------------------------

# Path to where the APK files are
ROOT_DIR = "APKs"

# Path to where the CICFlowMeter csvs are
CICFLOW_DIR = "cicflow_csvs"

# The file that contain the permissions (that will be extracted)
MANIFEST_FILE = "AndroidManifest.xml"

# Number of samples that will be extracted for each malware class
SAMPLES_EACH_CLASS = 4000

# Path where the dataset and balanced csvs will be stored
SAVE_PATH = "class_balanced_csvs"

# Define a seed to generate random numbers
random.seed(123456789)
# ----------------------------------------------------------------------------------------------------------------------

# Function that get a path to the AndroidManifest.xml and create a file *_permissions.txt with the manifest permissions
def get_permission(manifest_path):

    if (os.path.exists(manifest_path)):

        # Init the tree to read the XML file
        try:
            tree = ET.parse(manifest_path)
        except:
            print(manifest_path)
            return

        root = tree.getroot()

        # Define a name to store the list of permissions
        output_name = manifest_path.split("/")
        output_name = "_".join(output_name[1:-1]) + "_permissions.txt"
        output_dir = manifest_path.split("/")[:-1]
        output_dir = "/".join(output_dir)


        file = open(os.path.join(output_dir, output_name), "w")

        # Get the permissions and write them inside the output file
        for elem in root:
            if (str(elem.tag) == "uses-permission"):
                for key in elem.attrib.keys():
                    file.write(elem.attrib[key])
                    file.write("\n")

        file.close()
# ----------------------------------------------------------------------------------------------------------------------

# Run the APKTool and get the permissions of all APK files
def get_permissions():

    # Loop to look inside the malware dirs and generate, for each APK, the AndroidManifest.xml
    for root_malware_dir in os.listdir(ROOT_DIR):
        malware_dirs = os.path.join(ROOT_DIR, root_malware_dir)

        for malware_dir in os.listdir(malware_dirs):
            sub_malware_dirs = os.path.join(malware_dirs, malware_dir)

            for sub_malware in os.listdir(sub_malware_dirs):
                apks_dir = os.path.join(sub_malware_dirs, sub_malware)

                print("\nMalware Class: {} | Malware Subclass: {}\n".format(malware_dir.upper(), sub_malware.upper()))

                # Use the APKTool to get the files
                for apk_file in os.listdir(apks_dir):
                    apk_path = os.path.join(apks_dir, apk_file)
                    output_path = os.path.join(apks_dir, apk_file[:-4])
                    os.system("/usr/local/bin/apktool d {} -o {}".format(apk_path, output_path))

                    manifest_path = os.path.join(output_path, MANIFEST_FILE)
                    get_permission(manifest_path)
# ----------------------------------------------------------------------------------------------------------------------

# Read all the permissions extracted and create a set of them
def get_unique_permissions():
    unique_permissions = set()

    # Loop to look inside the malware dirs
    for root_malware_dir in os.listdir(ROOT_DIR):
        malware_dirs = os.path.join(ROOT_DIR, root_malware_dir)

        for malware_dir in os.listdir(malware_dirs):
            sub_malware_dirs = os.path.join(malware_dirs, malware_dir)

            for sub_malware in os.listdir(sub_malware_dirs):
                apks_dir = os.path.join(sub_malware_dirs, sub_malware)

                print("\nMalware Class: {} | Malware Subclass: {}\n".format(malware_dir.upper(), sub_malware.upper()))

                # Use the APKTool to get the files
                for apk_file in os.listdir(apks_dir):
                    apk_path = os.path.join(apks_dir, apk_file)

                    if(os.path.isdir(apk_path)):
                        output_path = os.path.join(apks_dir, apk_file)
                        manifest_path = os.path.join(output_path, MANIFEST_FILE)

                        filename = manifest_path.split("/")
                        filename = "_".join(filename[1:-1]) + "_permissions.txt"

                        perm_dir = manifest_path.split("/")[:-1]
                        perm_dir = "/".join(perm_dir)

                        path = os.path.join(perm_dir, filename)
                        if(os.path.exists(path)):
                            file = open(path, "r")
                            permissions = file.readlines()

                            for permission in permissions:
                                unique_permissions.add(permission.replace("\n", ""))

                            file.close()

    file = open("unique_permissions.txt", "w")
    file.write("\n".join(list(unique_permissions)))
    file.close()
# ----------------------------------------------------------------------------------------------------------------------

# Fuction that adds the found permissions to the CICFlowMeter csv (0: this permission is not needed and 1: this
# permission is needed).
def add_permissions_to_cicflowmeter_csvs():

    # Get all different permissions found in the apk files
    file = open("unique_permissions.txt", "r")
    unique_perms = [line.replace("\n", "") for line in file.readlines()]
    file.close()

    # Loop to look inside the malware dirs
    for root_malware_dir in os.listdir(ROOT_DIR):
        malware_dirs = os.path.join(ROOT_DIR, root_malware_dir)

        # Ex.: APKs/Adware-APKs files
        for malware_dir in os.listdir(malware_dirs):
            sub_malware_dirs = os.path.join(malware_dirs, malware_dir)

            # Ex.: APKs/Adware-APKs/Adware files
            for sub_malware in os.listdir(sub_malware_dirs):
                apks_dir = os.path.join(sub_malware_dirs, sub_malware)

                print("\nMalware Class: {} | Malware Subclass: {}\n".format(malware_dir, sub_malware))

                # CicFlowMeter different name dir for benign samples
                cicflow_sub_malware = sub_malware.lower()
                if("Benign" in malware_dir):
                    path_csvs = os.path.join(CICFLOW_DIR, "Benign", cicflow_sub_malware, "csv")
                    csvs = os.listdir(path_csvs)
                else:
                    path_csvs = os.path.join(CICFLOW_DIR, malware_dir, cicflow_sub_malware, "csv")
                    csvs = os.listdir(path_csvs)

                # Path to the dir that has the permission list
                path_permissions = os.path.join(ROOT_DIR, root_malware_dir, malware_dir, sub_malware)
                perms_dirs = os.listdir(path_permissions)

                # Get only the dirs (not the apks)
                perms_dirs = [file for file in perms_dirs if ".apk" not in file]

                # For each CICFlowMeters feature csv (corresponding to a pcap file)
                for csv in csvs:

                    # Get the pcap name
                    pcap_name = csv.split(".pcap")[0].split("-")[-1]

                    # If the APKTool found the corresponding list of permissions:
                    if(pcap_name in perms_dirs):

                        # Open the csv file (CICFlowMeter)
                        path_csv = os.path.join(path_csvs, csv)
                        cicflow_csv = pd.read_csv(path_csv)

                        # Get the corresponding permissions dir
                        perm_dir_path = os.path.join(path_permissions, pcap_name)
                        perm_dir = os.listdir(perm_dir_path)

                        # Select the .txt file with the permissions
                        perm_dir = [file for file in perm_dir if ".txt" in file]

                        # If a problem occured with APKTool, continue
                        if(perm_dir == []):
                            continue
                        else:
                            perm_dir = perm_dir[0]

                        # Open and read the permissions file
                        path_to_perm = os.path.join(perm_dir_path, perm_dir)
                        file = open(path_to_perm, "r")
                        permissions = [line.replace("\n", "") for line in file.readlines()]

                        # For each unique permission, add a column on the dataframe
                        for permission in unique_perms:

                            # Mark the existence of this permission
                            if(permission in permissions):
                                cicflow_csv[permission] = 1

                            # Mark that this permission does not exist
                            else:
                                cicflow_csv[permission] = 0

                        file.close()

                        # Create a new csv file to store the combined features
                        combined_file_path = os.path.join(path_csvs, csv[:-4] + "_with_permissions.csv")
                        cicflow_csv.to_csv(combined_file_path, index=False)
# ----------------------------------------------------------------------------------------------------------------------

# Function that performs a class balancing, extracting only "SAMPLES_EACH_CLASS" samples for each class
def generate_balanced_csv_each_class():

    # Gets the list of malware classes
    classes = os.listdir(CICFLOW_DIR)

    # For each malware class (Scareware, Benign, Adware, SMSMalware e Ransomware)
    for malware_class in classes:
        print("Generating the CSV file for {} Malware Class...".format(malware_class))

        # Gets the path to the current class and its subclasses
        path = os.path.join(CICFLOW_DIR, malware_class)
        subclasses = os.listdir(path)

        # Calculates the number of subclasses
        num_subclasses = int(len(subclasses))

        # Defines the number of samples that will be extract from each subclass
        num_samples = int(SAMPLES_EACH_CLASS / num_subclasses)
        amount = 0
        subclasses_csvs = []

        # For each subclasses inside the current class dir
        for index, subclass in enumerate(subclasses):

            # Control the number of samples extracted in case the division did not  result in an integer
            amount += num_samples

            # If the division did not result in an integer, complete the samples in the last subclass
            if (index == len(subclasses) - 1):
                num_samples += (SAMPLES_EACH_CLASS - amount)
                amount += (SAMPLES_EACH_CLASS - amount)

            # Gets the paths to the csv inside each subclass dir
            sub_path = os.path.join(path, subclass)
            csvs_path = os.path.join(sub_path, "csv")
            csvs = [csv for csv in os.listdir(csvs_path) if "with_permissions" in csv]

            # For each csv
            csvs_list = []
            for csv in csvs:

                # Gets the complete path
                csv_path = os.path.join(csvs_path, csv)

                # Read it
                data = pd.read_csv(csv_path)

                # Update the label column
                data["Label"] = malware_class.upper()

                # Add a column to inform the subclass
                data["Subclass"] = subclass.upper()

                # Add the current csv to a list
                csvs_list.append(data)

            # Combine all csv (same subclass)
            combined_csv = pd.concat(csvs_list, axis=0, ignore_index=True)

            # Creates a set that will be used to not repeat numbers when generating random indexes
            samples_indexes = set()

            # Select, randomly, the samples that will be used (max of 'num_samples')
            while (len(samples_indexes) < num_samples):
                index = random.randint(0, len(combined_csv) - 1)
                samples_indexes.add(index)
            samples_indexes = list(samples_indexes)

            # Select the chosen indexes and get the final subclass csv
            final_subclass_csv = combined_csv.iloc[samples_indexes]
            subclasses_csvs.append(final_subclass_csv)

        # Combine all the subclasses csv (representing the malware class csv)
        combined_class_csv = pd.concat(subclasses_csvs, axis=0, ignore_index=True)

        # Save it
        if (not os.path.exists(SAVE_PATH)):
            os.system("mkdir {}".format(SAVE_PATH))
        combined_class_csv.to_csv("{}/{}.csv".format(SAVE_PATH, malware_class.lower()), index=False)
# ----------------------------------------------------------------------------------------------------------------------

# Function that combines all the csvs generated by the previous function, shuffle the rows and save the new csv
def combine_all_classes_csv():
    all_csvs = []

    print("Generating the dataset...")

    # List the csv found by the previous function
    csv_paths = os.listdir(SAVE_PATH)

    # For each of them
    for csv_path in csv_paths:

        # Gets the complete path
        path = os.path.join(SAVE_PATH, csv_path)

        # Read it
        data = pd.read_csv(path)

        # Add it to a list
        all_csvs.append(data)

    # Combine the csv of all classes (representing the dataset)
    combined_csv = pd.concat(all_csvs, axis=0, ignore_index=True)

    # Shuffle the dataset
    combined_csv = combined_csv.sample(frac=1).reset_index(drop=True)

    # Save it
    combined_csv.to_csv("{}/dataset.csv".format(SAVE_PATH), index=False)
# ----------------------------------------------------------------------------------------------------------------------

if __name__ == "__main__":
    # get_permissions()
    # get_unique_permissions()
    # add_permissions_to_cicflowmeter_csvs()
    generate_balanced_csv_each_class()
    combine_all_classes_csv()
# ----------------------------------------------------------------------------------------------------------------------