# ----------------------------------------------------------------------------------------------------------------------
# File containing the class with the definitions and functions to run the KNN model for classification.
# ----------------------------------------------------------------------------------------------------------------------

import os, sys
import numpy as np
import pandas as pd
from sklearn.model_selection import GridSearchCV, StratifiedKFold
from sklearn.neighbors import KNeighborsClassifier

from metrics import Metrics
from constants import SAVE_PATH
from pre_processing import preprocess_data
# ----------------------------------------------------------------------------------------------------------------------

# KNN hyperparameters ranges that will be optimized
params = {
    "n_neighbors": [1, 5, 10, 50],
    "weights": ["uniform", "distance"],
    "algorithm": ["auto", "ball_tree", "kd_tree", "brute"],
    "leaf_size": [5, 30, 100],
    "p": [1, 2],
    "metric": ["minkowski"],
    "metric_params": [None],
    "n_jobs": [None]
}
# ----------------------------------------------------------------------------------------------------------------------

# Class to build, train, predict and optimize the KNN model
class KNN:

    # Defines default hyperparameters
    def __init__(self):
        self.n_neighbors = 5
        self.weights = "uniform"
        self.algorithm = "auto"
        self.leaf_size = 30
        self.p = 2
        self.metric = "minkowski"
        self.metric_params = None
        self.n_jobs = None
        self.model = KNeighborsClassifier()
        self.model_fit = None
    # ------------------------------------------------------------------------------------------------------------------

    # Build the model
    def build(self):
        self.model = KNeighborsClassifier(
            n_neighbors=self.n_neighbors,
            weights=self.weights,
            algorithm=self.algorithm,
            leaf_size=self.leaf_size,
            p=self.p,
            metric=self.metric,
            metric_params=self.metric_params,
            n_jobs=self.n_jobs
        )

    # Function to set new hyperparameters after the model has been built
    def set_params(self, n_neighbors=5, weights="uniform", algorithm="auto", leaf_size=30, p=2, metric="minkowski",
                         metric_params=None, n_jobs=None):

        self.n_neighbors = n_neighbors
        self.weights = weights
        self.algorithm = algorithm
        self.leaf_size = leaf_size
        self.p = p
        self.metric = metric
        self.metric_params = metric_params
        self.n_jobs = n_jobs
        self.build()
    # ------------------------------------------------------------------------------------------------------------------

    # Train it
    def train(self, features, labels):
        self.model_fit = self.model.fit(features, labels)
    # ------------------------------------------------------------------------------------------------------------------

    # Predict it
    def predict(self, features):
        prediction = self.model.predict(features)
        return(prediction)
    # ------------------------------------------------------------------------------------------------------------------

    # Optimize the model with the hyperparameters intervals defined previously
    def optimize(self, parameters, features, labels):

        # Init the 5-fold object
        skf = StratifiedKFold(n_splits=5)

        # Init the classifier
        clf = KNeighborsClassifier()

        # Init the Grid Search
        grid = GridSearchCV(estimator=clf, param_grid=parameters, verbose=3, cv=skf, return_train_score=True,
                            refit="recall_score")

        # Train it
        sys.stdout = open("knn_tune.csv", "w")
        grid.fit(features, labels)

        # Get the results and filter it
        results = pd.DataFrame(grid.cv_results_)
        filtered_result = results[['params', 'rank_test_score', 'mean_test_score']]

        print("\nOverall Results:")
        print(filtered_result)

        print("\nBest Params:")
        print(grid.best_params_)

        print("\nBest Score:")
        print(grid.best_score_)

        sys.stdout.close()
    # ------------------------------------------------------------------------------------------------------------------

    # Get the predicted probability of testing data
    def predict_probabilities(self, test_features):
        score = self.model.predict_proba(test_features)[:, 1]
        return(score)
    # ------------------------------------------------------------------------------------------------------------------

# ----------------------------------------------------------------------------------------------------------------------

if __name__ == "__main__":

    # Read the dataset
    path = os.path.join(SAVE_PATH, "dataset.csv")
    dataset = pd.read_csv(path)

    # Preprocess the data
    train_set, val_set, test_set = preprocess_data(dataset)

    # Build the model
    knn = KNN()

    # Optimize it
    ext_train_set = {"features": np.vstack([train_set["features"], val_set["features"]]), "labels": np.hstack([train_set["labels"], val_set["labels"]])}
    # knn.optimize(params, ext_train_set["features"], ext_train_set["labels"])

    # Train it
    knn.train(train_set["features"], train_set["labels"])

    # Init the 5-fold object
    cv = StratifiedKFold(n_splits=5)
    for i, (train, test) in enumerate(cv.split(test_set["features"], test_set["labels"])):

        # Train it
        knn.train(test_set["features"][train], test_set["labels"][train])

        # Get the probabilities of each class
        class_scores = knn.model.predict_proba(test_set["features"][test])

        # Make the prediction
        predicted = knn.predict(test_set["features"][test])
        expected = test_set["labels"][test]

        # Init the metrics class with the classes (to get the order)
        metrics = Metrics(knn.model.classes_)

        # Calculates the Accuracy, Precision, Recall and F1-Score for each class
        metrics.get_all_metrics(expected, predicted)

        # Calculates the confusion matrix
        metrics.get_confusion_matrix(expected, predicted, save=True, model="{}_knn".format(i))

        # Calculates the AUC
        metrics.get_auc(expected, class_scores)

        # Calculates and plots the ROC
        metrics.get_roc(expected, class_scores)

        # Show Accuracy, Precision, Recall, F1-Score, AUC and Confusion Matrix
        metrics.print_all_metrics()
# ----------------------------------------------------------------------------------------------------------------------