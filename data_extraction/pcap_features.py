# ----------------------------------------------------------------------------------------------------------------------
import os
import random
import numpy as np
import pandas as pd
# ----------------------------------------------------------------------------------------------------------------------

# Where the CICFlowMeter csvs are
ROOT = "./cicflow_csvs/"

# Number of samples that will be extracted for each malware class
SAMPLES_EACH_CLASS = 2000

# Path where the dataset and balanced csvs will be stored
SAVE_PATH = "class_balanced_csvs"

# Define a seed to generate random numbers
random.seed(123456789)
# ----------------------------------------------------------------------------------------------------------------------

# Function that performs a class balancing, extracting only "SAMPLES_EACH_CLASS" samples for each class
def generate_balanced_csv_each_class():

    # Gets the list of malware classes
    classes = os.listdir(ROOT)

    # For each malware class (Scareware, Benign, Adware, SMSMalware e Ransomware)
    for malware_class in classes:
        print("Generating the CSV file for {} Malware Class...".format(malware_class))

        # Gets the path to the current class and its subclasses
        path = os.path.join(ROOT, malware_class)
        subclasses = os.listdir(path)

        # Calculates the number of subclasses
        num_subclasses = int(len(subclasses))

        # Defines the number of samples that will be extract from each subclass
        num_samples = int(SAMPLES_EACH_CLASS / num_subclasses)
        amount = 0
        subclasses_csvs = []

        # For each subclasses inside the current class dir
        for index, subclass in enumerate(subclasses):

            # Control the number of samples extracted in case the division did not  result in an integer
            amount += num_samples

            # If the division did not result in an integer, complete the samples in the last subclass
            if (index == len(subclasses) - 1):
                num_samples += (SAMPLES_EACH_CLASS - amount)
                amount += (SAMPLES_EACH_CLASS - amount)

            # Gets the paths to the csv inside each subclass dir
            sub_path = os.path.join(path, subclass)
            csvs_path = os.path.join(sub_path, "csv")
            csvs = os.listdir(csvs_path)

            # For each csv
            csvs_list = []
            for csv in csvs:

                # Gets the complete path
                csv_path = os.path.join(csvs_path, csv)

                # Read it
                data = pd.read_csv(csv_path)

                # Update the label column
                data["Label"] = malware_class.upper()

                # Add a column to inform the subclass
                data["Subclass"] = subclass.upper()

                # Add the current csv to a list
                csvs_list.append(data)

            # Combine all csv (same subclass)
            combined_csv = pd.concat(csvs_list, axis=0, ignore_index=True)

            # Creates a set that will be used to not repeat numbers when generating random indexes
            samples_indexes = set()

            # Select, randomly, the samples that will be used (max of 'num_samples')
            while (len(samples_indexes) < num_samples):
                index = random.randint(0, len(combined_csv) - 1)
                samples_indexes.add(index)
            samples_indexes = list(samples_indexes)

            # Select the chosen indexes and get the final subclass csv
            final_subclass_csv = combined_csv.iloc[samples_indexes]
            subclasses_csvs.append(final_subclass_csv)

        # Combine all the subclasses csv (representing the malware class csv)
        combined_class_csv = pd.concat(subclasses_csvs, axis=0, ignore_index=True)

        # Save it
        if (not os.path.exists(SAVE_PATH)):
            os.system("mkdir {}".format(SAVE_PATH))
        combined_class_csv.to_csv("{}/{}.csv".format(SAVE_PATH, malware_class.lower()), index=False)
# ----------------------------------------------------------------------------------------------------------------------

# Function that combines all the csvs generated by the previous function, shuffle the rows and save the new csv
def combine_all_classes_csv():
    all_csvs = []

    print("Generating the dataset...")

    # List the csv found by the previous function
    csv_paths = os.listdir(SAVE_PATH)

    # For each of them
    for csv_path in csv_paths:

        # Gets the complete path
        path = os.path.join(SAVE_PATH, csv_path)

        # Read it
        data = pd.read_csv(path)

        # Add it to a list
        all_csvs.append(data)

    # Combine the csv of all classes (representing the dataset)
    combined_csv = pd.concat(all_csvs, axis=0, ignore_index=True)

    # Shuffle the dataset
    combined_csv = combined_csv.sample(frac=1).reset_index(drop=True)

    # Save it
    combined_csv.to_csv("{}/dataset.csv".format(SAVE_PATH), index=False)
# ----------------------------------------------------------------------------------------------------------------------

if __name__ == "__main__":
    generate_balanced_csv_each_class()
    combine_all_classes_csv()
    # TODO: Add the APKs features
# ----------------------------------------------------------------------------------------------------------------------